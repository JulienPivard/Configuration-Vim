priority -45

global !p

def ada_case(word):
	out = word[0].upper()
	for i in range(1, len(word)):
		if word[i] == '-':
			out = out + '.'
		elif word[i - 1] == '_' or word[i - 1] == '-':
			out = out + word[i].upper()
		else:
			out = out + word[i]
	return out

endglobal

snippet pac "package"
--  @summary
--  Une petite explication
--  @description
--  Une description plus longue
--  @group Un nom de groupe
package ${1:`!p snip.rv = ada_case(snip.basename)`}
	with
		Pure           => True,
		Preelaborate   => False,
		Elaborate_Body => False,
		Spark_Mode     => Off
is
	$0
end $1;
endsnippet

snippet pacb "package body"
package body ${1:`!p snip.rv = ada_case(snip.basename)`}
	with Spark_Mode => Off
is
	$0

	---------------------------------------------------------------------------
	--                             Partie privée                             --
	---------------------------------------------------------------------------

end $1;
endsnippet

snippet taskb "task body"
---------------------------------------------------------------------------
task body $1 is
	$2
begin
	$0
end $1;
---------------------------------------------------------------------------
endsnippet

snippet ent "entry ... when"
entry $1
	($2)
	when $3
is
begin
	$0
end $1;
endsnippet

snippet acc "accept"
accept $1
	($2)
do
	$0
end $1;
endsnippet

snippet protd "protected object declaration"
protected $1
is
	$0
end $1;
endsnippet

snippet prot_typ "protected type"
protected type $1
	($2)
is
	$0
end $1;
endsnippet

snippet prob "protected body"
---------------------------------------------------------------------------
protected body $1 is
	$0
end $1;
---------------------------------------------------------------------------
endsnippet

snippet decn "declare named block"
$1 :
declare
	$2
begin
	$0
end $1;
endsnippet

snippet nwh "named while"
$1 :
while $2 loop
	$0
end loop $1;
endsnippet

snippet nfor "named for"
$1 :
for ${2:I} in $3 loop
	$0
end loop $1;
endsnippet

snippet nfore "named for each"
$1 :
for $2 of $3 loop
	$0
end loop $1;
endsnippet

snippet proc "procedure"
---------------------------------------------------------------------------
procedure $1
	($2)
is
	$3
begin
	$0
end $1;
---------------------------------------------------------------------------
endsnippet

snippet procd "procedure declaration"
procedure $1;$0
--  Description contenu
--  @param nom_param
--  Description paramètre
endsnippet

snippet fun "function"
---------------------------------------------------------------------------
function $1
	($2)
	return $3
is
	$4
begin
	$0
end $1;
---------------------------------------------------------------------------
endsnippet

snippet fund "function declaration"
function $1 return $2;$0
--  Description contenu
--  @param nom_param
--  Description paramètre
--  @return Ce que retourne la fonction
endsnippet

snippet nlo "named loop"
$1 :
loop
	$0
end loop $1;
endsnippet

snippet put "Ada.Text_IO.Put"
Ada.Text_IO.Put (Item => $1);$0
endsnippet

snippet putl "Ada.Text_IO.Put_Line"
Ada.Text_IO.Put_Line (Item => $1);$0
endsnippet

snippet wwput "Ada.Wide_Wide_Text_IO.Put"
Ada.Wide_Wide_Text_IO.Put (Item => $1);$0
endsnippet

snippet wwputl "Ada.Wide_Wide_Text_IO.Put_Line"
Ada.Wide_Wide_Text_IO.Put_Line (Item => $1);$0
endsnippet

snippet get "Ada.Text_IO.Get"
Ada.Text_IO.Get (Item => $1);$0
endsnippet

snippet getl "Ada.Text_IO.Get_Line"
Ada.Text_IO.Get_Line (Item => $1);$0
endsnippet

snippet newline "Ada.Text_IO.New_Line"
Ada.Text_IO.New_Line (Spacing => ${1:1});$0
endsnippet

snippet obso "pragma Obsolescent"
pragma Obsolescent ($1, "$2");$0
endsnippet

snippet unref "pragma Unreferenced"
pragma Unreferenced ($1);$0
endsnippet

# vim:ft=snippets:
